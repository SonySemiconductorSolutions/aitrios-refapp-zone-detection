# Copyright 2025 Sony Semiconductor Solutions Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
import base64
import datetime
import logging
import urllib
from tempfile import TemporaryDirectory
from time import sleep
from time import time
from typing import Optional

from app.client.client_interface import ClientInferface
from app.client.client_interface import StatusResponse
from app.config.get_console_settings import get_console_settings
from app.schemas.configuration import ConfigurationV2
from app.schemas.device import Device
from app.schemas.device import Devices
from app.utils.auth import get_token
from app.utils.timestamp import convert_iso_timestamp_to_numeric
from console_v2_api_client import ApiClient
from console_v2_api_client import ApiException
from console_v2_api_client import Configuration
from console_v2_api_client import DeviceCommandApi
from console_v2_api_client import InsightApi
from console_v2_api_client import ManageDevicesApi
from console_v2_api_client.models.device import Device as DeviceConsoleV2
from console_v2_api_client.models.device import Device as DeviceV2Info
from console_v2_api_client.models.execute_command_json_body import (
    ExecuteCommandJsonBody,
)
from console_v2_api_client.models.execute_device_command200_response import (
    ExecuteDeviceCommand200Response,
)
from console_v2_api_client.models.get_property200_response import GetProperty200Response
from console_v2_api_client.models.inferenceresults_get200_response import (
    InferenceresultsGet200Response,
)
from console_v2_api_client.models.update_configuration_json_body import (
    UpdateConfigurationJsonBody,
)
from console_v2_api_client.models.update_device_configuration200_response import (
    UpdateDeviceConfiguration200Response,
)
from fastapi import HTTPException
from pydantic import ValidationError


logger = logging.getLogger(__name__)


def _remove_empty_entries(dictionary: any) -> any:
    if not isinstance(dictionary, dict):
        return dictionary
    return {k: _remove_empty_entries(v) for k, v in dictionary.items() if v is not None}


def _process_configuration_for_sending(configuration: ConfigurationV2) -> dict:
    json_configuration = configuration.model_dump()
    return _remove_empty_entries(json_configuration)


class OnlineConsoleClientV2(ClientInferface):
    NUM_RETRIES = 10
    WAIT_SECONDS = 0.25

    def __init__(self, timeout=None):
        super().__init__(timeout)
        self.__api_client = None
        self.token_expiry = time()

    def _get_client(self):
        """
        Get autogenerated API Client to interact with Online Console v2

        Returns:
            ApiClient: Python API Client
        """
        try:
            logger.debug("Attempting to create Online Console API v2 client.")
            (
                console_endpoint,
                client_id,
                client_secret,
                portal_authorization_endpoint,
            ) = get_console_settings()
            access_token, expires_in = get_token(
                client_id=client_id,
                client_secret=client_secret,
                portal_authorization_endpoint=portal_authorization_endpoint,
            )

            self.token_expiry = time() + expires_in - 10  # Add a safety buffer

            configuration = Configuration(host=console_endpoint)
            api_client = ApiClient(
                configuration=configuration,
                header_name="Authorization",
                header_value=f"Bearer {access_token}",
            )
            logger.info("Online Console API v2 client successfully created.")

            return api_client
        except Exception as e:
            logger.error(
                f"Failed to create Online Console API v2 client: {e}", exc_info=True
            )
            raise HTTPException(
                status_code=500, detail=f"Unable to create API client: {str(e)}"
            )

    def get_client(self):
        if self.__api_client is None or time() >= self.token_expiry:
            logger.info("Initializing Online Console API v2 client connection.")
            self.__api_client = self._get_client()
        return self.__api_client

    def reload_client(self):
        logger.info("Reloading Online Console API client connection.")
        self.__api_client = self._get_client()

    def get_devices(self) -> Devices:
        logger.debug("Fetching device list from Online Console.")
        try:
            api_instance = ManageDevicesApi(self.get_client())
            response = api_instance.get_devices()
            device_list = [
                Device(
                    device_id=device.device_id,
                    device_name=device.device_name,
                    connection_state=device.connection_state,
                )
                for device in response.devices
            ]
            logger.info(f"Successfully fetched {len(device_list)} devices.")
            return Devices(devices=device_list)
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching devices: {api_error}", exc_info=True
            )
            raise

    def get_device(self, device_id: str) -> Device:
        def _get_model_id_list(_device_info: DeviceConsoleV2) -> list[str]:
            return_list = []
            for chip_info in _device_info.var_property.state["device_info"]["chips"]:
                if chip_info["name"] != "sensor_chip":
                    continue
                for model in chip_info["ai_models"]:
                    if model["version"] != "":
                        return_list.append(model["version"][6:12])
            return return_list

        try:
            logger.debug(f"Fetching details for device ID {device_id}.")
            api_instance = ManageDevicesApi(self.get_client())
            response: DeviceConsoleV2 = api_instance.get_device(
                device_id=device_id, _request_timeout=self.timeout
            )
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching device with ID {device_id}: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API Error while fetching device with ID {device_id}: {api_error}"
            )

        try:
            if "device_info" not in response.var_property.state:
                raise TypeError("Device is not a v2 device.")
            models_list = [
                f"{model_info.model_id} ({model_id})"
                for model_info, model_id in zip(
                    response.models, _get_model_id_list(response)
                )
            ]
            device = Device(
                device_id=device_id,
                device_name=response.device_name,
                connection_state=response.connection_state,
                models=models_list,
                application=[module.module_name for module in response.modules],
                inference_status=response.var_property.state["device_states"][
                    "process_state"
                ],
            )

            logger.info(f"Successfully fetched details for device ID {device_id}.")
            return device
        except AttributeError as attr_error:
            logger.error(f"Response attribute error: {attr_error}", exc_info=True)
            raise Exception(f"Response attribute error: {attr_error}")
        except TypeError as type_error:
            logger.error(f"Version mismatch: {type_error}", exc_info=True)
            raise Exception(f"Version mismatch: {type_error}")
        except Exception as error:
            logger.error(f"Unexpected Error during processing: {error}", exc_info=True)
            raise Exception(f"Unexpected Error during processing: {error}")

    def _get_module_id_from_device(self, device_id: str) -> str:
        manage_device_api: ManageDevicesApi = ManageDevicesApi(self.get_client())

        try:
            device_info: DeviceV2Info = manage_device_api.get_device(
                device_id=device_id
            )
        except ApiException as api_error:
            logger.error(
                f"Error while retrieving device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"Error while retrieving device with ID {device_id}: {api_error}"
            )

        return device_info.modules[0].module_id

    def get_configuration(self, device_id: str) -> ConfigurationV2:
        module_id: str = self._get_module_id_from_device(device_id=device_id)

        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())
        try:
            module_info: GetProperty200Response = device_command_api.get_property(
                device_id=device_id, module_id=module_id
            )
        except ApiException as api_error:
            logger.error(
                f"Error while retrieving property from device {device_id} with ID {module_id}: {api_error}"
            )
            raise Exception(
                f"Error while retrieving property from device {device_id} with ID {module_id}: {api_error}"
            )
        try:
            validatedConfig = ConfigurationV2.model_validate(
                module_info.var_property.state
            )
        except ValidationError as validation_error:
            logger.error(
                f"Missing / Unexpected fields in device configuration: device {device_id} with ID {module_id}: {validation_error}"  # include pydantic error details in console log
            )
            raise Exception(
                f"Missing / Unexpected fields in device configuration: device {device_id} with ID {module_id}"
            )

        return validatedConfig

    async def update_configuration(
        self, device_id: str, configuration: ConfigurationV2
    ) -> StatusResponse:
        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

        module_id: str = self._get_module_id_from_device(device_id=device_id)

        json_configuration = _process_configuration_for_sending(configuration)

        return StatusResponse(
            status=device_command_api.update_module_configuration(
                device_id=device_id,
                module_id=module_id,
                update_configuration_json_body=UpdateConfigurationJsonBody(
                    configuration=json_configuration
                ),
                _request_timeout=self.timeout,
            ).result
        )

    async def set_configuration(
        self, device_id: str, configuration: ConfigurationV2
    ) -> StatusResponse:
        raise ApiException("Online Console V2 does not support this endpoint")

    def get_direct_image(self, device_id: str) -> str:
        try:
            response: ExecuteDeviceCommand200Response = DeviceCommandApi(
                self.get_client()
            ).execute_device_command(
                device_id=device_id,
                execute_command_json_body=ExecuteCommandJsonBody(
                    command_name="direct_get_image",
                    parameters={
                        "crop_h_offset": 0,
                        "crop_v_offset": 0,
                        "crop_h_size": 2028,
                        "crop_v_size": 1520,
                        "sensor_name": "IMX500",
                    },
                ),
            )
        except ApiException as api_error:
            logger.error(
                f"Error while fetching direct image from device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"API error while retrieving direct image from device id {device_id}: {api_error}"
            )

        error_msg = None
        if response.result != "SUCCESS":
            error_msg = response.result

        image = response.command_response["image"]
        if len(image) == 0:
            error_msg = "Image received is empty"

        if error_msg is not None:
            raise Exception(
                f"Error while fetching direct image from device with ID {device_id}: {error_msg}"
            )

        return image

    def _get_latest_inference(self, device_id: str) -> dict:
        insight_api = InsightApi(self.get_client())
        try:
            response: InferenceresultsGet200Response = insight_api.inferenceresults_get(
                devices=[device_id], limit=1, _request_timeout=self.timeout
            )

            if response.inferences is None or len(response.inferences) == 0:
                raise Exception(
                    f"Device {device_id} has not produced any inference. Make sure you have started inference properly."
                )
        except ApiException as api_error:
            logger.error(
                f"API error while retrieving data from device id {device_id}: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while retrieving data from device id {device_id}: {api_error}"
            )

        return {
            "timestamp": response.inferences[0].inferences[0].t,
            "content": response.inferences[0].inferences[0].o,
        }

    def _get_input_tensor_subdirectory_from_configuration(
        self,
        configuration: ConfigurationV2,
    ) -> str:
        return configuration.edge_app.common_settings.port_settings.input_tensor.path.split(
            "/"
        )[
            -1
        ]

    def _get_image_name_from_inference_timestamp(self, timestamp: str) -> str:
        return convert_iso_timestamp_to_numeric(timestamp)

    def _get_image_from_inference(self, device_id: str, latest_inference: dict) -> str:
        device_configuration: ConfigurationV2 = self.get_configuration(device_id)
        subdirectory_name: str = self._get_input_tensor_subdirectory_from_configuration(
            device_configuration
        )
        image_name = self._get_image_name_from_inference_timestamp(
            latest_inference["timestamp"]
        )

        insight_api = InsightApi(self.get_client())

        image_url = None
        for _ in range(OnlineConsoleClientV2.NUM_RETRIES):
            try:
                image_urls = [
                    x.sas_url
                    for x in insight_api.get_images(
                        device_id=device_id,
                        sub_directory_name=subdirectory_name,
                        name_starts_with=image_name,
                        limit=1,
                    ).data
                ]
            except ApiException as api_error:
                logger.error(
                    f"API error while retrieving data from device id {device_id}: {api_error}",
                    exc_info=True,
                )
                raise Exception(
                    f"API error while retrieving data from device id {device_id}: {api_error}"
                )

            if len(image_urls) > 0:
                image_url = image_urls[0]
                break

            sleep(OnlineConsoleClientV2.WAIT_SECONDS)

        if image_url is None:
            raise Exception(
                f"Image {image_name} not found in directory {subdirectory_name}"
            )

        with TemporaryDirectory() as tmpdir_path:
            image_filepath: str = tmpdir_path + f"/{image_name}.png"
            urllib.request.urlretrieve(image_url, image_filepath)
            with open(image_filepath, "rb") as f:
                return base64.b64encode(f.read()).decode("utf-8")

    def get_latest_data(
        self, device_id: str, get_image: bool = False
    ) -> tuple[Optional[str], dict[str, str]]:
        logger.debug(
            f"Fetching latest data for device ID '{device_id}'. Get image: {get_image}"
        )

        latest_inference = self._get_latest_inference(device_id)

        image_content = (
            self._get_image_from_inference(device_id, latest_inference)
            if get_image
            else None
        )

        logger.info(
            f"Successfully retrieved image and inference data for device ID '{device_id}'"
        )
        return image_content, latest_inference

    def _update_process_state(
        self, _device_id: str, _module_id: str, _process_state: int
    ) -> UpdateDeviceConfiguration200Response:
        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

        configuration = {
            "edge_app": {"common_settings": {"process_state": _process_state}}
        }

        return device_command_api.update_module_configuration(
            device_id=_device_id,
            module_id=_module_id,
            update_configuration_json_body=UpdateConfigurationJsonBody(
                configuration=configuration
            ),
            _request_timeout=self.timeout,
        )

    def _check_input_tensor_path_follows_convention(
        self, folder_path: str, device_id: str
    ) -> bool:
        folder_path_elements = folder_path.split("/")
        if len(folder_path_elements) != 3:
            return False

        folder_path_device_id = folder_path_elements[0]
        folder_path_image_element = folder_path_elements[1]
        folder_path_subfolder = folder_path_elements[2]

        if (
            folder_path_device_id != device_id
            or folder_path_image_element != "image"
            or folder_path_subfolder == ""
        ):
            return False

        return True

    def _validate_and_adapt_input_tensor_path(
        self, folder_path: str, device_id: str
    ) -> str:
        curr_date = datetime.datetime.now().strftime("%Y%m%d-%H%M%S%f")

        if folder_path is None or folder_path == "":
            return f"{device_id}/image/{curr_date}"

        folder_path_elements = folder_path.split("/")
        if not self._check_input_tensor_path_follows_convention(folder_path, device_id):
            # Verification that the images path follows the expected format of {device_id}/image/{subfolder}
            return f"{device_id}/image/{curr_date}"
        else:
            prev_folder_parent = "/".join(folder_path_elements[:-1])
            try:
                datetime.datetime.strptime(
                    folder_path.split("/")[-1], "%Y%m%d-%H%M%S%f"
                )

                # If the image subfolder is a date, replace it with the current one
                return f"{prev_folder_parent}/{curr_date}"
            except ValueError:
                # Otherwise, return the path as it is
                return folder_path

    def start_upload_inference_data(
        self, device_id: str, get_image: bool = False
    ) -> StatusResponse:

        logger.debug(
            f"Starting upload inference data for device ID '{device_id}'. Get image: {get_image}"
        )
        try:
            module_id: str = (
                ManageDevicesApi(self.get_client())
                .get_device(device_id=device_id)
                .modules[0]
                .module_id
            )

            # Getting current configuration to be updated
            device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

            if get_image:
                prev_configuration: ConfigurationV2 = self.get_configuration(device_id)
                prev_folder = (
                    prev_configuration.edge_app.common_settings.port_settings.input_tensor.path
                )
                new_inference_folder = self._validate_and_adapt_input_tensor_path(
                    prev_folder, device_id=device_id
                )

                configuration = {
                    "edge_app": {
                        "common_settings": {
                            "port_settings": {
                                "input_tensor": {
                                    "path": new_inference_folder,
                                    "enabled": True,
                                }
                            }
                        }
                    }
                }

            else:
                configuration = {
                    "edge_app": {
                        "common_settings": {
                            "port_settings": {"input_tensor": {"enabled": False}}
                        }
                    }
                }

            # Start inference
            configuration["edge_app"]["common_settings"]["process_state"] = 2

            response = device_command_api.update_module_configuration(
                device_id=device_id,
                module_id=module_id,
                update_configuration_json_body=UpdateConfigurationJsonBody(
                    configuration=configuration
                ),
                _request_timeout=self.timeout,
            )

            insight_api = InsightApi(self.get_client())
            latest_inference_id: str = (
                insight_api.inferenceresults_get(
                    devices=[device_id], limit=1, _request_timeout=self.timeout
                )
                .inferences[0]
                .id
            )

            start_time = time()
            time_out_secs = 60
            while (
                latest_inference_id
                == insight_api.inferenceresults_get(
                    devices=[device_id], limit=1, _request_timeout=self.timeout
                )
                .inferences[0]
                .id
            ):
                logger.info("Waiting for the device to start...")
                if time() - start_time > time_out_secs:
                    raise Exception("Timeout while waiting for device to start.")

            logger.debug(
                f"[start_upload_inference_data] Device started, status response: {response.result}"
            )
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while starting to upload inference data: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while starting to upload inference data: {api_error}"
            )

    def stop_upload_inference_data(self, device_id: str) -> StatusResponse:
        logger.debug(f"Stopping upload inference data for device ID '{device_id}'.")
        try:
            manage_devices_api = ManageDevicesApi(self.get_client())
            device_info: DeviceConsoleV2 = manage_devices_api.get_device(
                device_id=device_id
            )

            response = self._update_process_state(
                _device_id=device_id,
                _module_id=device_info.modules[0].module_id,
                _process_state=1,
            )
            logger.info(
                f"Successfully stopped upload inference data for device ID '{device_id}'."
            )
            if isinstance(response.result, str):
                return StatusResponse(status=response.result)
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while stopping to upload inference data: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while stopping to upload inference data: {api_error}"
            )

    def delete_device_data(self, device_id: str) -> StatusResponse:
        """Deletes all image directories and inference data related to the given device."""
        logger.debug(f"Initiating deletion of all data from device '{device_id}'.")
        try:
            insight_api = InsightApi(self.get_client())

            self._delete_image_directories(insight_api, device_id)
            self._delete_inference_results(insight_api, device_id)

            logger.info(f"Successfully deleted all data for device {device_id}")
            return StatusResponse(status="Success")
        except ApiException as api_error:
            logger.error(f"API error while deleting data from {device_id}: {api_error}")
            raise Exception(
                f"API error while deleting data from {device_id}: {api_error}"
            )

    def _delete_image_directories(self, insight_api: InsightApi, device_id: str):
        """Deletes all image directories for the specified device."""
        response = insight_api.get_image_directories(
            device_id, _request_timeout=self.timeout
        )

        if not response or not response[0].devices:
            logger.debug(f"No image directories found for device {device_id}")
            return

        image_dirs = response[0].devices[0].image
        logger.debug(
            f"Found {len(image_dirs)} image directories for deletion on {device_id}"
        )

        for sub_directory in image_dirs:
            insight_api.delete_images(
                device_id=device_id,
                sub_directory_name=sub_directory,
                delete_images_json_body={"directory_deletion": "1"},
                _request_timeout=self.timeout,
            )
            logger.debug(f"Deleted image directory '{sub_directory}' from {device_id}")

    def _delete_inference_results(self, insight_api: InsightApi, device_id: str):
        """Deletes all inference results for the specified device in batches."""
        batch_size = 100

        while True:
            inferences: InferenceresultsGet200Response = (
                insight_api.inferenceresults_get(
                    devices=[device_id], limit=batch_size, _request_timeout=self.timeout
                )
            )
            if not inferences.inferences:
                logger.debug(
                    f"No more inference results to delete for device {device_id}"
                )
                break

            item_ids = [i.id for i in inferences.inferences]
            insight_api.delete_inference_results(
                device_id=device_id, item_ids=",".join(item_ids)
            )
            logger.debug(f"Deleted {len(item_ids)} inference results for {device_id}")
