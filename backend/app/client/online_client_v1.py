# Copyright 2025 Sony Semiconductor Solutions Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
import json
import logging
from base64 import b64encode
from time import time
from typing import Optional

from app.client.client_interface import ClientInferface
from app.client.client_interface import Device
from app.client.client_interface import Devices
from app.client.client_interface import StatusResponse
from app.config.get_console_settings import get_console_settings
from app.schemas.configuration import ConfigurationV1
from app.utils.auth import get_token
from console_api_client import ApiClient
from console_api_client import ApiException
from console_api_client import CommandParameterFileApi
from console_api_client import Configuration
from console_api_client import DeviceCommandApi
from console_api_client import GetInferenceResults200ResponseInner
from console_api_client import InsightApi
from console_api_client import ManageDevicesApi
from console_api_client import RegistCommandParameterFileBody
from fastapi import HTTPException
from urllib3.exceptions import MaxRetryError
from urllib3.exceptions import ReadTimeoutError


logger = logging.getLogger(__name__)


def get_last_inference_id(response: list[GetInferenceResults200ResponseInner]) -> str:
    return response[-1].id if len(response) != 0 else ""


class OnlineConsoleClientV1(ClientInferface[ConfigurationV1]):

    def __init__(self, timeout=None):
        super().__init__(timeout)
        self.__api_client = None
        self.token_expiry = time()

    def _get_client(self):
        """
        Get autogenerated API Client to interact with Online Console

        Returns:
            ApiClient: Python API Client
        """
        try:
            logger.debug("Attempting to create Online Console API client.")
            (
                console_endpoint,
                client_id,
                client_secret,
                portal_authorization_endpoint,
            ) = get_console_settings()
            access_token, expires_in = get_token(
                client_id=client_id,
                client_secret=client_secret,
                portal_authorization_endpoint=portal_authorization_endpoint,
            )

            self.token_expiry = time() + expires_in - 10  # Add a safety buffer

            configuration = Configuration(host=console_endpoint)
            api_client = ApiClient(
                configuration=configuration,
                header_name="Authorization",
                header_value=f"Bearer {access_token}",
            )
            logger.info("Online Console API client successfully created.")

            return api_client
        except Exception as e:
            logger.error(f"Failed to create Online Console API client: {e}")
            raise HTTPException(
                status_code=500, detail=f"Unable to create API client: {str(e)}"
            )

    def get_client(self):
        if self.__api_client is None or time() >= self.token_expiry:
            logger.info("Initializing Online Console API client connection.")
            self.__api_client = self._get_client()
        return self.__api_client

    def reload_client(self):
        logger.info("Reloading Online Console API client connection.")
        self.__api_client = self._get_client()

    def get_devices(self) -> Devices:
        logger.debug("Fetching device list from Online Console.")
        try:
            api_instance = ManageDevicesApi(self.get_client())
            response = api_instance.get_devices(_request_timeout=self.timeout)
            device_list = [
                Device(
                    device_id=device.device_id,
                    device_name=device.var_property.device_name,
                    connection_state=device.connection_state,
                )
                for device in response.devices
            ]
            logger.info(f"Successfully fetched {len(device_list)} devices.")
            return Devices(devices=device_list)
        except ApiException as api_error:
            logger.error(f"API Error while fetching devices: {api_error.reason}")
            raise Exception(f"Failed to fetch devices: {api_error.reason}")
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(f"Transport Error while fetching devices: {transport_error}")
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def get_device(self, device_id: str) -> Device:
        try:
            logger.debug(f"Fetching details for device ID {device_id}.")
            api_instance = ManageDevicesApi(self.get_client())
            response = api_instance.get_device(
                device_id=device_id, _request_timeout=self.timeout
            )
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"API Error while fetching device with ID {device_id}: {api_error}"
            )

        try:
            if "Status" not in response.state:
                raise TypeError("Device is not a v1 device.")

            device = Device(
                device_id=device_id,
                device_name=response.var_property.device_name,
                connection_state=response.connection_state,
                models=[
                    model_dict.model_version_id.split(":")[0]
                    for model_dict in response.models
                ],
                application=[app.name for app in response.apps],
                inference_status=response.state["Status"]["Sensor"],
            )
            logger.info(f"Successfully fetched details for device ID {device_id}.")
            return device
        except AttributeError as attr_error:
            logger.error(f"Response attribute error: {attr_error}")
            raise Exception(f"Response attribute error: {attr_error}")
        except TypeError as type_error:
            logger.error(f"Version mismatch: {type_error}", exc_info=True)
            raise Exception(f"Version mismatch: {type_error}")
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while fetching device info {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")
        except Exception as error:
            logger.error(f"Unexpected Error during processing: {error}")
            raise Exception(f"Unexpected Error during processing: {error}")

    def get_configuration(self, device_id: str) -> ConfigurationV1:
        try:
            api_instance = CommandParameterFileApi(self.get_client())
            response = api_instance.get_command_parameter_file(
                _request_timeout=self.timeout
            )
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching configuration file for device id {device_id}: {api_error}"
            )
            raise Exception(
                f"API Error while fetching configuration file for device id {device_id}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while fetching configuration file for device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

        try:
            file_name = ""
            param_list = response.parameter_list
            for param in param_list:
                device_ids = param.device_ids
                if device_id in device_ids:
                    file_name = param.file_name
                    break
        except Exception as error:
            logger.error(f"Unexpected Error during processing: {error}")
            raise Exception(f"Unexpected Error during processing: {error}")

        if not file_name:
            logger.error("Selected device does not have any configuration file")
            raise Exception("Selected device does not have any configuration file")
        logger.info(
            f"Configuration file successfully retrieved for device ID {device_id}."
        )
        return ConfigurationV1(
            file_name=file_name,
            commands=[c.to_dict() for c in param.parameter.commands],
        )

    async def update_configuration(
        self, device_id: str, configuration: ConfigurationV1
    ) -> StatusResponse:
        try:
            logger.debug(f"Updating configuration file: {configuration.file_name}.")
            api_instance = CommandParameterFileApi(self.get_client())
            request_params = json.loads(configuration.model_dump_json())

            # Removing "None" parameters, as otherwise the validation of the payload fails
            for key, value in list(request_params["commands"][0]["parameters"].items()):
                if value is None:
                    request_params["commands"][0]["parameters"].pop(key)

            json_str = json.dumps(request_params)

            payload = {
                "parameter": b64encode(json_str.encode("utf-8")).decode("utf-8"),
                "comment": "",
            }
            response = api_instance.update_command_parameter_file(
                file_name=configuration.file_name,
                update_command_parameter_file_body=payload,
                _request_timeout=self.timeout,
            )
            logger.info(
                f"Successfully updated configuration file: {configuration.file_name}."
            )
            if isinstance(response.result, str):
                return StatusResponse(status=response.result)
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"Error while updating configuration file {configuration.file_name}: {api_error}"
            )
            raise Exception(
                f"API error while updating configuration file {configuration.file_name}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while updating configuration file {configuration.file_name}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    async def set_configuration(
        self, device_id: str, configuration: ConfigurationV1
    ) -> StatusResponse:
        logger.debug(
            f"Putting a new configuration using Console V1 on device: {device_id}"
        )

        api_instance = CommandParameterFileApi(self.get_client())
        file_name: str = configuration.file_name
        request_params = json.loads(configuration.model_dump_json())

        # Removing "None" parameters, as otherwise the validation of the payload fails
        for key, value in list(request_params["commands"][0]["parameters"].items()):
            if value is None:
                request_params["commands"][0]["parameters"].pop(key)

        json_str = json.dumps(request_params)
        logger.debug(f"Registering file name: {file_name}")
        try:
            payload = RegistCommandParameterFileBody.model_validate(
                {
                    "file_name": file_name,
                    "parameter": b64encode(json_str.encode("utf-8")).decode("utf-8"),
                    "comment": "",
                }
            )
            response_register = api_instance.regist_command_parameter_file(
                regist_command_parameter_file_body=payload,
                _request_timeout=self.timeout,
            )
        except ApiException as api_error:
            logger.error(
                f"Error while registering configuration file {file_name}: {api_error}",
            )
            raise Exception(
                f"API error while registering a new configuration file {file_name}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while registering configuration file {file_name}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

        logger.info(f"Successfully registered configuration file: {file_name}.")
        if (
            isinstance(response_register.result, str)
            and response_register.result != "SUCCESS"
        ):
            return StatusResponse(status=response_register.result)

        logger.debug(
            f"Binding configuration file '{file_name}' to device ID '{device_id}'."
        )
        try:
            response_bind = api_instance.bind_command_parameter_file_to_device(
                file_name=file_name,
                bind_command_parameter_file_to_device_json_body={
                    "device_ids": device_id
                },
                _request_timeout=self.timeout,
            )
        except ApiException as api_error:
            logger.error(
                f"API error while applying configuration file to device id {device_id}: {api_error}"
            )
            raise Exception(
                f"API error while applying configuration file to device id {device_id}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while applying configuration file to device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

        logger.info(
            f"Successfully bound file '{file_name}' to device ID '{device_id}'."
        )
        if isinstance(response_bind.result, str):
            return StatusResponse(status=response_bind.result)
        return StatusResponse(status=response_bind.result)

    def get_direct_image(self, device_id: str) -> str:
        logger.debug(f"Fetching direct image for device ID '{device_id}'.")
        try:
            api_instance = DeviceCommandApi(self.get_client())
            response = api_instance.get_direct_image(
                device_id=device_id, _request_timeout=self.timeout
            )
            logger.info("Successfully fetched image content.")
            return response.contents
        except ApiException as api_error:
            logger.error(
                f"Error while fetching direct image from device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"API error while retrieving direct image from device id {device_id}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while retrieving direct image from device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def get_latest_data(
        self, device_id: str, get_image: bool = False
    ) -> tuple[Optional[str], dict[str, str]]:
        logger.debug(
            f"Fetching latest data for device ID '{device_id}'. Get image: {get_image}"
        )
        try:
            insight_api = InsightApi(self.get_client())
            if get_image:
                response = insight_api.get_image_directories(
                    device_id, _request_timeout=self.timeout
                )
                response = insight_api.get_images(
                    device_id=device_id,
                    sub_directory_name=response[0].devices[0].image[-1],
                    order_by="DESC",
                    number_of_images=1,
                    _request_timeout=self.timeout,
                )
                image_content = response.images[0].contents

                response = insight_api.get_inference_results(
                    device_id=device_id,
                    raw=1,
                    time=response.images[0].name.split(".")[0],
                    _request_timeout=self.timeout,
                )
            else:
                image_content = None
                response = insight_api.get_inference_results(
                    device_id=device_id,
                    raw=1,
                    number_of_inferenceresults=1,
                    _request_timeout=self.timeout,
                )

            inference = {
                "timestamp": None,
                "content": None,
            }
            if len(response[0].inference_result.inferences) != 0:
                inference = {
                    "timestamp": response[0].inference_result.inferences[0].t,
                    "content": response[0].inference_result.inferences[0].o,
                }
            logger.info(
                f"Successfully retrieved image and inference data for device ID '{device_id}'"
            )
            return image_content, inference
        except ApiException as api_error:
            logger.error(
                f"API error while retrieving data from device id {device_id}: {api_error}"
            )
            raise Exception(
                f"API error while retrieving data from device id {device_id}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while retrieving data from device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def start_upload_inference_data(
        self, device_id: str, get_image: bool = False
    ) -> StatusResponse:
        logger.debug(
            f"Starting upload inference data for device ID '{device_id}'. Get image: {get_image}"
        )
        try:
            device_api = DeviceCommandApi(self.get_client())
            insight_api = InsightApi(self.get_client())
            start_time = time()
            time_out_secs = self.timeout
            if get_image:
                response = insight_api.get_image_directories(
                    device_id, _request_timeout=self.timeout
                )
                previous_directories = response[0].devices[0].image
                response = device_api.start_upload_inference_result(
                    device_id, _request_timeout=self.timeout
                )
                while (
                    insight_api.get_image_directories(device_id)[0].devices[0].image
                    == previous_directories
                ):
                    logger.info("Waiting for the creation of new image directory...")
                    if time() - start_time > time_out_secs:
                        raise Exception("Timeout while waiting for device to start.")

                logger.debug(
                    f"[start_upload_inference_data] Image directory created, status response: {response.result}"
                )
            else:
                response = insight_api.get_inference_results(
                    device_id,
                    number_of_inferenceresults=1,
                    _request_timeout=self.timeout,
                )
                last_inference_id = get_last_inference_id(response)
                response = device_api.start_upload_inference_result(
                    device_id, _request_timeout=self.timeout
                )
                while last_inference_id == get_last_inference_id(
                    insight_api.get_inference_results(
                        device_id,
                        number_of_inferenceresults=1,
                        _request_timeout=self.timeout,
                    )
                ):
                    logger.info("Waiting for the device to start...")
                    if time() - start_time > time_out_secs:
                        raise Exception("Timeout while waiting for device to start.")
                logger.debug(
                    f"[start_upload_inference_data] Device started, status response: {response.result}"
                )
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while starting to upload inference data: {api_error}"
            )
            raise Exception(
                f"API error while starting to upload inference data: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while starting to upload data from device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def stop_upload_inference_data(self, device_id: str) -> StatusResponse:
        logger.debug(f"Stopping upload inference data for device ID '{device_id}'.")
        try:
            device_api = DeviceCommandApi(self.get_client())
            response = device_api.stop_upload_inference_result(
                device_id, _request_timeout=self.timeout
            )
            logger.info(
                f"Successfully stopped upload inference data for device ID '{device_id}'."
            )
            if isinstance(response.result, str):
                return StatusResponse(status=response.result)
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while stopping to upload inference data: {api_error}"
            )
            raise Exception(
                f"API error while stopping to upload inference data: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while stopping to upload inference data from device id {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def delete_device_data(self, device_id: str) -> StatusResponse:
        """Deletes all image directories and inference data related to the given device."""
        logger.debug(f"Initiating deletion of device '{device_id}' data.")
        try:
            insight_api = InsightApi(self.get_client())

            self._delete_image_directories(insight_api, device_id)
            self._delete_inference_results(insight_api, device_id)

            logger.info(f"Successfully deleted all data for device {device_id}")
            return StatusResponse(status="Success")
        except ApiException as api_error:
            logger.error(f"API error while deleting data from {device_id}: {api_error}")
            raise Exception(
                f"API error while deleting data from {device_id}: {api_error}"
            )
        except (MaxRetryError, ReadTimeoutError) as transport_error:
            logger.error(
                f"Transport Error while deleting data from {device_id}: {transport_error}"
            )
            raise Exception(f"Transport error occurred: {str(transport_error)}")

    def _delete_image_directories(self, insight_api: InsightApi, device_id: str):
        """Deletes all image directories for the specified device."""
        response = insight_api.get_image_directories(
            device_id, _request_timeout=self.timeout
        )

        if not response or not response[0].devices:
            logger.debug(f"No image directories found for device {device_id}")
            return

        image_dirs = response[0].devices[0].image
        logger.debug(
            f"Found {len(image_dirs)} image directories for deletion on {device_id}"
        )

        for sub_directory in image_dirs:
            insight_api.delete_images_stable(
                device_id=device_id,
                sub_directory_name=sub_directory,
                delete_images_json_body_stable={"directory_deletion": "1"},
                _request_timeout=self.timeout,
            )
            logger.debug(f"Deleted image directory '{sub_directory}' from {device_id}")

    def _delete_inference_results(self, insight_api: InsightApi, device_id: str):
        """Deletes all inference results for the specified device in batches."""
        batch_size = 100

        while True:
            inferences = insight_api.get_inference_results(
                device_id=device_id, number_of_inferenceresults=batch_size
            )
            if not inferences:
                logger.debug(
                    f"No more inference results to delete for device {device_id}"
                )
                break

            item_ids = [i.id for i in inferences]
            insight_api.delete_inference_results(
                device_id=device_id, item_ids=",".join(item_ids)
            )
            logger.debug(f"Deleted {len(item_ids)} inference results for {device_id}")
